<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.121/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link href="style.css" rel="stylesheet">
</head>

<body>
  <div id="cesiumContainer" class="fullSize"></div>
  <div id="loadingOverlay">
    <h1>Loading...</h1>
  </div>
  <div id="toolbar"></div>
</body>
<script>
  Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwMGQ2OTY0OS05OWNiLTRmZDctYTcwNi1lYTY1NTVhODBhNDYiLCJpZCI6MjM5MTExLCJpYXQiOjE3MjU0NTU0ODZ9.JbglzGJ8dBc1tbZbb9GTKEuRlxyE6mXZKIWJ7E_diW4';
  const viewer = new Cesium.Viewer("cesiumContainer", {
    //设置地形
    terrain: Cesium.Terrain.fromWorldTerrain(),
  });
  //启用深度测试，确保物体和地形间的遮挡关系准确
  viewer.scene.globe.depthTestAgainstTerrain = true;


  /**
  // Set the initial camera view to look at Manhattan
  //设置相机初始视角，经度纬度高程转化为三维笛卡尔坐标系
  const initialPosition = Cesium.Cartesian3.fromDegrees(
    112.56, //经度
    28.22,  //纬度
    753                 //高程
  );

  //设置相机朝向，航向、俯仰和横滚
  const initialOrientation = new Cesium.HeadingPitchRoll.fromDegrees(
    21.27879878293835,  //水平，以北为0度，顺时针为正
    -21.34390550872461, //俯仰，水平向上为正
    0.0716951918898415  //侧倾，
  );

  //设置相机视角
  viewer.scene.camera.setView({
    destination: initialPosition,
    orientation: initialOrientation,
    endTransform: Cesium.Matrix4.IDENTITY, //重置相机的参考框架，确保相机在地球表面上的正常定位和移动。
  });
  **/


  // 加载3D模型
  async function loadingTileset() {
    const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(2733869);
    viewer.scene.primitives.add(tileset);
    viewer.flyTo(tileset);
  }
  loadingTileset()

  //鼠标悬停在3D tiles显示信息，这里进行初步创建，不显示
  const nameOverlay = document.createElement("div");
  viewer.container.appendChild(nameOverlay);
  nameOverlay.className = "backdrop";
  nameOverlay.style.display = "none";
  nameOverlay.style.position = "absolute";
  nameOverlay.style.bottom = "0";
  nameOverlay.style.left = "0";
  nameOverlay.style["pointer-events"] = "none";
  nameOverlay.style.padding = "4px";
  nameOverlay.style.backgroundColor = "black";

  //选中的feature的信息
  const selected = {
    feature: undefined,
    originalColor: new Cesium.Color(),
  };

  //Entity用来表示场景中的抽象对象
  const selectedEntity = new Cesium.Entity();

  //获取 Cesium 中 左键点击 (LEFT_CLICK) 事件的默认处理程序
  const clickHandler = viewer.screenSpaceEventHandler.getInputAction(
    Cesium.ScreenSpaceEventType.LEFT_CLICK
  );


  //根据点击的feature更新nameOverlay，并且显示在鼠标位置
  function updateNameOverlay(pickedFeature, position) {
    if (!Cesium.defined(pickedFeature)) {
      //如果点击的pickedFeature不存在，则进入
      nameOverlay.style.display = "none";
      return;
    }
    // A feature was picked, so show its overlay content
    //如果存在，则执行
    nameOverlay.style.display = "block";
    nameOverlay.style.bottom = `${viewer.canvas.clientHeight - position.y
      }px`;
    nameOverlay.style.left = `${position.x}px`;
    //const name = pickedFeature.getProperty("BIN");
    //nameOverlay.textContent = "国际控股"; //div的纯文本内容

  }


  //生成一个选中 pickedFeature 的 HTML 表格，并将其返回
  function createPickedFeatureDescription(pickedFeature) {
    const description =
      `${'<table class="cesium-infoBox-defaultTable"><tbody>' +
      "<tr><th>BIN</th><td>"
      }${pickedFeature.getProperty("BIN")}</td></tr>` +
      `<tr><th>DOITT ID</th><td>${pickedFeature.getProperty(
        "DOITT_ID"
      )}</td></tr>` +
      `<tr><th>SOURCE ID</th><td>${pickedFeature.getProperty(
        "SOURCE_ID"
      )}</td></tr>` +
      `<tr><th>Longitude</th><td>${pickedFeature.getProperty(
        "Longitude"
      )}</td></tr>` +
      `<tr><th>Latitude</th><td>${pickedFeature.getProperty(
        "Latitude"
      )}</td></tr>` +
      `<tr><th>Height</th><td>${pickedFeature.getProperty(
        "Height"
      )}</td></tr>` +
      `<tr><th>Terrain Height (Ellipsoid)</th><td>${pickedFeature.getProperty(
        "TerrainHeight"
      )}</td></tr>` +
      `</tbody></table>`;
    return description;
  }

  //如果支持轮廓（silhouettes）效果，则鼠标悬停时轮廓呈现蓝色，点击时轮廓呈现绿色
  //如果不支持轮廓（silhouettes）效果，则鼠标悬停时整个建筑呈现黄色，点击时整个建筑呈现绿色
  if (
    Cesium.PostProcessStageLibrary.isSilhouetteSupported(viewer.scene)
    //判断当前场景是否支持轮廓效果
  ) {
    //如果支持轮廓效果
    //创建边缘检测阶段（轮廓检测），用于检测并显示物体的轮廓
    const silhouetteBlue = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
    silhouetteBlue.uniforms.color = Cesium.Color.BLUE;//轮廓颜色
    silhouetteBlue.uniforms.length = 0.01;//轮廓宽度
    silhouetteBlue.selected = [];

    const silhouetteGreen = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
    silhouetteGreen.uniforms.color = Cesium.Color.LIME;
    silhouetteGreen.uniforms.length = 0.01;
    silhouetteGreen.selected = [];

    //创建轮廓阶段，并将蓝色和绿色轮廓都加入，以便分别应用于不同交互行为（悬停和点击）
    viewer.scene.postProcessStages.add(
      Cesium.PostProcessStageLibrary.createSilhouetteStage([
        silhouetteBlue,
        silhouetteGreen,
      ])
    );
    //悬停时（hover）轮廓为蓝色
    viewer.screenSpaceEventHandler.setInputAction(function onMouseMove(
      movement  //根据screenSpaceEventHandler的鼠标事件设置setInputAction，当类型为MOUSE_MOVE时，回调函数的参数即movement有endPosition属性
    ) {
      //如果feature已经高亮了，则取消高亮
      silhouetteBlue.selected = [];

      // 得到当前鼠标下的地物
      const pickedFeature = viewer.scene.pick(movement.endPosition);

      //更新NameOverlay
      updateNameOverlay(pickedFeature, movement.endPosition);

      if (!Cesium.defined(pickedFeature)) {
        //如果pickedFeature为空，则结束
        return;
      }

      //下面这个判断的作用自行体会
      if (pickedFeature !== selected.feature) {
        silhouetteBlue.selected = [pickedFeature];//显示边缘为蓝色
      }
    },
      Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // 同理，设置左点击事件
    viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(
      movement
    ) {
      // 重置
      silhouetteGreen.selected = [];

      // Pick a new feature
      const pickedFeature = viewer.scene.pick(movement.position);
      if (!Cesium.defined(pickedFeature)) {
        clickHandler(movement);
        return;
      }

      // 如果重复点击，则不用处理，直接结束
      if (silhouetteGreen.selected[0] === pickedFeature) {
        return;
      }

      //如果点击的地物与你鼠标悬停位置的地物一致，则先把悬停的蓝色轮廓去空
      const highlightedFeature = silhouetteBlue.selected[0];
      if (pickedFeature === highlightedFeature) {
        silhouetteBlue.selected = [];
      }

      // 然后让轮廓变绿
      silhouetteGreen.selected = [pickedFeature];

      // Set feature infobox description
      viewer.selectedEntity = selectedEntity;
      selectedEntity.description = createPickedFeatureDescription(
        pickedFeature
      );
    },
      Cesium.ScreenSpaceEventType.LEFT_CLICK);
  } else {
    // 如果不支持轮廓（silhouettes）效果，则鼠标悬停时整个建筑呈现黄色，点击时整个建筑呈现绿色
    // 如果不支持轮廓效果，那么我们需要存储颜色信息

    // 高亮地物的信息，这是悬停时的地物信息，不是选中，选中的selected信息在最上面
    const highlighted = {
      feature: undefined,
      originalColor: new Cesium.Color(),
    };

    // 悬停时整体为黄色
    viewer.screenSpaceEventHandler.setInputAction(function onMouseMove(
      movement
    ) {
      // 1. 取消之前高亮显示的特征
      if (Cesium.defined(highlighted.feature)) {
        highlighted.feature.color = highlighted.originalColor;
        highlighted.feature = undefined;
      }
      // 2. 检测鼠标下的新特征
      const pickedFeature = viewer.scene.pick(movement.endPosition);
      updateNameOverlay(pickedFeature, movement.endPosition);

      if (!Cesium.defined(pickedFeature)) {
        return;
      }

      // 3. 如果新特征不是当前选中的特征，则高亮显示
      if (pickedFeature !== selected.feature) {
        highlighted.feature = pickedFeature;
        //把pickedFeature的color复制给highlighted
        Cesium.Color.clone(
          pickedFeature.color,
          highlighted.originalColor
        );
        pickedFeature.color = Cesium.Color.YELLOW;
      }
    },
      Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // 点击事件还有处理infobo显示
    viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(
      movement
    ) {
      // 1. 取消之前高亮显示的特征
      if (Cesium.defined(selected.feature)) {
        selected.feature.color = selected.originalColor;
        selected.feature = undefined;
      }
      // 2. 检测鼠标下的新特征
      const pickedFeature = viewer.scene.pick(movement.position);
      if (!Cesium.defined(pickedFeature)) {
        clickHandler(movement);
        return;
      }
      //如果重复点击则直接结束
      if (selected.feature === pickedFeature) {
        return;
      }
      selected.feature = pickedFeature;
      // 3. 如果新特征是当前悬停的特征，则高亮显示
      if (pickedFeature === highlighted.feature) {
        Cesium.Color.clone(
          highlighted.originalColor,//点击的时候，highlighted的originalColor是原始数据颜色
          selected.originalColor
        );
        highlighted.feature = undefined;
      } else {
        Cesium.Color.clone(pickedFeature.color, selected.originalColor);
      }
      // Highlight newly selected feature
      pickedFeature.color = Cesium.Color.LIME;

      // Set feature infobox description
      viewer.selectedEntity = selectedEntity;
      selectedEntity.description = createPickedFeatureDescription(
        pickedFeature
      );
    },
      Cesium.ScreenSpaceEventType.LEFT_CLICK);
  } 
</script>

</html>